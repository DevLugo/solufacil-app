import 'package:equatable/equatable.dart';

/// PersonalData model - Core entity for clients and employees
class PersonalData extends Equatable {
  final String id;
  final String fullName;
  final String? clientCode;
  final DateTime? birthDate;
  final DateTime createdAt;
  final DateTime updatedAt;

  // Related data (populated from joins)
  final List<String> phones;
  final List<AddressInfo> addresses;

  const PersonalData({
    required this.id,
    required this.fullName,
    this.clientCode,
    this.birthDate,
    required this.createdAt,
    required this.updatedAt,
    this.phones = const [],
    this.addresses = const [],
  });

  /// Get primary phone number
  String? get primaryPhone => phones.isNotEmpty ? phones.first : null;

  /// Get primary address
  AddressInfo? get primaryAddress => addresses.isNotEmpty ? addresses.first : null;

  /// Check if client code is auto-generated (longer than 15 chars)
  bool get hasAutoGeneratedCode =>
      clientCode != null && clientCode!.length > 15;

  /// Display code (null if auto-generated)
  String? get displayCode => hasAutoGeneratedCode ? null : clientCode;

  factory PersonalData.fromRow(Map<String, dynamic> row, {
    List<String> phones = const [],
    List<AddressInfo> addresses = const [],
  }) {
    return PersonalData(
      id: row['id'] as String,
      fullName: row['fullName'] as String? ?? '',
      clientCode: row['clientCode'] as String?,
      birthDate: row['birthDate'] != null
          ? DateTime.tryParse(row['birthDate'] as String)
          : null,
      createdAt: DateTime.parse(row['createdAt'] as String),
      updatedAt: DateTime.parse(row['updatedAt'] as String),
      phones: phones,
      addresses: addresses,
    );
  }

  @override
  List<Object?> get props => [
        id,
        fullName,
        clientCode,
        birthDate,
        createdAt,
        updatedAt,
        phones,
        addresses,
      ];
}

/// Address information with location details
class AddressInfo extends Equatable {
  final String id;
  final String? street;
  final String? locationName;
  final String? municipalityName;
  final String? stateName;
  final String? routeName;

  const AddressInfo({
    required this.id,
    this.street,
    this.locationName,
    this.municipalityName,
    this.stateName,
    this.routeName,
  });

  /// Full address string
  String get fullAddress {
    final parts = <String>[];
    if (street != null && street!.isNotEmpty) parts.add(street!);
    if (locationName != null && locationName!.isNotEmpty) parts.add(locationName!);
    if (municipalityName != null && municipalityName!.isNotEmpty) {
      parts.add(municipalityName!);
    }
    if (stateName != null && stateName!.isNotEmpty) parts.add(stateName!);
    return parts.join(', ');
  }

  /// Short address (location, municipality)
  String get shortAddress {
    final parts = <String>[];
    if (locationName != null && locationName!.isNotEmpty) parts.add(locationName!);
    if (municipalityName != null && municipalityName!.isNotEmpty) {
      parts.add(municipalityName!);
    }
    return parts.join(', ');
  }

  factory AddressInfo.fromRow(Map<String, dynamic> row) {
    return AddressInfo(
      id: row['id'] as String,
      street: row['street'] as String?,
      locationName: row['locationName'] as String?,
      municipalityName: row['municipalityName'] as String?,
      stateName: row['stateName'] as String?,
      routeName: row['routeName'] as String?,
    );
  }

  @override
  List<Object?> get props => [
        id,
        street,
        locationName,
        municipalityName,
        stateName,
        routeName,
      ];
}
